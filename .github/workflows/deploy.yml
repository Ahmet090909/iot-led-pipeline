name: Build, extract binary and deploy to Raspberry Pi

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  IMAGE_TAG: fast090909/iot-led-pipeline:${{ github.sha }}
  CONTAINER_NAME: build-temp-container
  BINARY_NAME: mybinary
  BINARY_PATH_IN_IMAGE: /app/mybinary
  REMOTE_DEST_PATH: /home/${{ secrets.PI_USER }}/mybinary
  TMUX_SESSION: app-session

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set up QEMU (for emulation)
        uses: docker/setup-qemu-action@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Build ARM image and load into runner (single-platform, no-cache)
        uses: docker/build-push-action@v5
        with:
          context: .
          push: false
          load: true
          no-cache: true
          platforms: linux/arm64
          tags: ${{ env.IMAGE_TAG }}
          build-args: |
            CACHEBUST=${{ github.run_id }}

      - name: Create container from image
        run: |
          if ! docker image inspect "${{ env.IMAGE_TAG }}" >/dev/null 2>&1; then
            IMG=$(docker images -q | head -n1)
            docker create --name "${{ env.CONTAINER_NAME }}" "$IMG"
          else
            docker create --name "${{ env.CONTAINER_NAME }}" "${{ env.IMAGE_TAG }}"
          fi

      - name: Copy executable out of container
        run: |
          set -euo pipefail
          echo "IMAGE_TAG=${{ env.IMAGE_TAG }}"
          echo "CONTAINER_NAME=${{ env.CONTAINER_NAME }}"
          echo "BINARY_PATH_IN_IMAGE=${{ env.BINARY_PATH_IN_IMAGE }}"
          echo "BINARY_NAME=${{ env.BINARY_NAME }}"

          if ! docker image inspect "${{ env.IMAGE_TAG }}" >/dev/null 2>&1; then
            IMG=$(docker images -q | head -n1)
            if [ -z "$IMG" ]; then
              echo "ERROR: no docker images found on runner"
              docker images
              exit 1
            fi
            docker create --name "${{ env.CONTAINER_NAME }}" "$IMG"
          fi

          # Try to copy the binary out of the container
          docker cp "${{ env.CONTAINER_NAME }}:${{ env.BINARY_PATH_IN_IMAGE }}" "./${{ env.BINARY_NAME }}" || {
            echo "ERROR: docker cp failed. Verify BINARY_PATH_IN_IMAGE is correct and file exists inside the image."
            docker container ls -a
            docker inspect "${{ env.CONTAINER_NAME }}" || true
            exit 1
          }

          chmod +x ./"${{ env.BINARY_NAME }}" || true
          echo "Local copy created:"
          ls -la ./"${{ env.BINARY_NAME }}"

      - name: Remove temporary container
        if: always()
        run: docker rm -f "${{ env.CONTAINER_NAME }}" || true

      - name: Prepare SSH private key
        run: |
          # write private key from secret reliably (preserves newlines)
          printf '%s\n' "${{ secrets.PI_SSH_PRIVATE_KEY }}" > private_key
          chmod 600 private_key

      - name: Add Pi host to known_hosts
        run: |
          mkdir -p ~/.ssh
          if [ -n "${{ secrets.PI_SSH_PORT }}" ]; then
            ssh-keyscan -p "${{ secrets.PI_SSH_PORT }}" -H "${{ secrets.PI_HOST }}" >> ~/.ssh/known_hosts || true
          else
            ssh-keyscan -H "${{ secrets.PI_HOST }}" >> ~/.ssh/known_hosts || true
          fi
          chmod 644 ~/.ssh/known_hosts

      - name: Copy binary to Raspberry Pi (with debug & retries)
        run: |
          set -euo pipefail

          echo "Working dir: $(pwd)"
          echo "Expect binary: ./${{ env.BINARY_NAME }}"
          ls -la ./${{ env.BINARY_NAME }} || { echo "Binary not found!"; exit 1; }

          PORT="${{ secrets.PI_SSH_PORT || '22' }}"
          DEST_USER="${{ secrets.PI_USER }}"
          DEST_HOST="${{ secrets.PI_HOST }}"
          echo "PI_USER: $DEST_USER"
          echo "PI_HOST: $DEST_HOST"

          if [ -z "$DEST_USER" ] || [ -z "$DEST_HOST" ]; then
            echo "ERROR: PI_USER or PI_HOST secret is empty; please set repository secrets."
            exit 1
          fi

          DEST="${DEST_USER}@${DEST_HOST}:${{ env.REMOTE_DEST_PATH }}"
          echo "Destination: $DEST"

          attempt=1
          until [ $attempt -gt 3 ]; do
            echo "scp try #$attempt..."
            scp -o ConnectTimeout=10 -o IdentitiesOnly=yes -o StrictHostKeyChecking=yes -P "$PORT" -i private_key ./${{ env.BINARY_NAME }} "$DEST" && break
            attempt=$((attempt+1))
            echo "scp failed, retrying in 5s..."
            sleep 5
          done
          if [ $attempt -gt 3 ]; then
            echo "scp failed after 3 attempts"
            exit 1
          fi

      - name: Restart binary on Raspberry Pi inside tmux
        run: |
          PORT=${{ secrets.PI_SSH_PORT || '22' }}
          SSH_OPTS="-o ConnectTimeout=10 -o IdentitiesOnly=yes -o StrictHostKeyChecking=yes -i private_key"
          ssh $SSH_OPTS -p "$PORT" "${{ secrets.PI_USER }}"@"${{ secrets.PI_HOST }}" \
            "set -e; \
             tmux kill-session -t '${{ env.TMUX_SESSION }}' || true; \
             if [ -f '${{ env.REMOTE_DEST_PATH }}' ]; then mv '${{ env.REMOTE_DEST_PATH }}' '${{ env.REMOTE_DEST_PATH }}.bak'; fi; \
             chmod +x '${{ env.REMOTE_DEST_PATH }}' || true; \
             tmux new -d -s '${{ env.TMUX_SESSION }}' '${{ env.REMOTE_DEST_PATH }}'"
